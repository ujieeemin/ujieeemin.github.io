<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>가짜뉴스 전파 시뮬레이터</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 50%, #90caf9 100%);
            min-height: 100vh;
            margin: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .step-navigation {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: linear-gradient(45deg, #818DFF);
            border-radius: 15px;
            color: white;
        }

        .step-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        .step-circle {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            margin: 0 10px;
            transition: all 0.3s ease;
        }

            .step-circle.active {
                background: white;
                color: #2196f3;
                transform: scale(1.2);
            }

            .step-circle.completed {
                background: #27ae60;
                color: white;
            }

            .step-circle.inactive {
                background: rgba(255,255,255,0.3);
                color: rgba(255,255,255,0.7);
            }

        .step-line {
            flex: 1;
            height: 4px;
            background: rgba(255,255,255,0.3);
            margin: 0 5px;
        }

            .step-line.completed {
                background: #27ae60;
            }

        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .nav-button {
            padding: 12px 25px;
            background: white;
            color: #2196f3;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

            .nav-button:hover {
                background: #ecf0f1;
                transform: translateY(-2px);
            }

            .nav-button:disabled {
                background: rgba(255,255,255,0.3);
                color: rgba(255,255,255,0.5);
                cursor: not-allowed;
                transform: none;
            }

        .section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            border-left: 5px solid #6170FF;
            display: none;
            backdrop-filter: blur(5px);
        }

            .section.active {
                display: block;
                animation: fadeIn 0.5s ease-in-out;
            }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .step-title {
            font-size: 28px;
            font-weight: bold;
            color: white;
            text-align: center;
            margin-bottom: 10px;
        }

        .step-description {
            text-align: center;
            color: rgba(255,255,255,0.9);
            margin-bottom: 20px;
        }

        .section h2 {
            color: #2c3e50;
            margin-top: 0;
            font-size: 1.5em;
        }

        input, select, button {
            padding: 10px 15px;
            margin: 5px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

            input:focus, select:focus {
                border-color: #2196f3;
                outline: none;
                box-shadow: 0 0 10px rgba(33, 150, 243, 0.3);
            }

        button {
            background: linear-gradient(45deg, #6170FF, #1976d2);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

            button:hover {
                background: linear-gradient(45deg, #1976d2, #2196f3);
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            }

            button:disabled {
                background: #bdc3c7;
                cursor: not-allowed;
                transform: none;
            }

        .connection-block {
            border: 2px solid #2196f3;
            border-radius: 10px;
            padding: 12px 16px;
            font-size: 16px;
            background: linear-gradient(45deg, #fafafa, #f5f5f5);
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 8px;
            display: inline-block;
        }

            .connection-block:hover {
                transform: scale(1.05);
                box-shadow: 0 5px 20px rgba(33, 150, 243, 0.15);
            }

        .from-node {
            color: #e74c3c;
            font-weight: bold;
        }

        .to-node {
            color: #3498db;
            font-weight: bold;
        }

        .green-bold {
            color: #27ae60;
            font-weight: bold;
        }

        #edgeList, #blockList, #startList {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        #graphArea {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        #network {
            border: 2px solid #ddd;
            border-radius: 15px;
            padding: 10px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            min-height: 520px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stats-panel, .log-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .infected-item {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 8px;
            font-weight: bold;
        }

        .infected {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #f44336;
        }

        .newly-infected {
            background: #fff3e0;
            color: #ef6c00;
            border-left: 4px solid #ff9800;
            animation: pulse 1s infinite;
        }

        .blocked {
            background: #f3e5f5;
            color: #7b1fa2;
            border-left: 4px solid #9c27b0;
        }

        .healthy {
            background: #e8f5e8;
            color: #2e7d32;
            border-left: 4px solid #4caf50;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
        }

        .simulation-controls {
            text-align: center;
            margin: 20px 0;
        }

            .simulation-controls button {
                font-size: 18px;
                padding: 15px 30px;
                margin: 0 10px;
            }

        .step-info {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            margin: 20px 0;
            padding: 15px;
            background: linear-gradient(45deg, #fff, #f8f9fa);
            border-radius: 10px;
            border: 2px solid #2196f3;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            transition: width 0.5s ease;
        }

        .user-setup {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .user-card {
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

            .user-card.blocked {
                border-color: #9c27b0;
                background: #f3e5f5;
            }

        .trust-slider {
            width: 100%;
            margin: 10px 0;
        }

        .simulation-log {
            max-height: 400px;
            overflow-y: auto;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

            .log-entry:last-child {
                border-bottom: none;
            }

        .spread-rate {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
        }

        .spread-high {
            background: #ffebee;
            color: #c62828;
        }

        .spread-medium {
            background: #fff3e0;
            color: #ef6c00;
        }

        .spread-low {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .final-results {
            background: linear-gradient(45deg, #fff, #f8f9fa);
            border: 3px solid #2196f3;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
        }

            .final-results h3 {
                color: #2c3e50;
                font-size: 1.8em;
                margin-bottom: 20px;
            }

        .stat-item {
            display: inline-block;
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            min-width: 150px;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #9c27b0;
        }

        .stat-label {
            color: #7f8c8d;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🦠 가짜뉴스 전파 시뮬레이터</h1>

        <!-- 단계 네비게이션 -->
        <div class="step-navigation">
            <div class="step-title" id="stepTitle">1단계: 사용자 설정</div>
            <div class="step-description" id="stepDescription">네트워크에 참여할 사용자들을 추가하고 신뢰도를 설정하세요</div>

            <div class="step-indicator">
                <div class="step-circle active" id="step1">1</div>
                <div class="step-line" id="line1"></div>
                <div class="step-circle inactive" id="step2">2</div>
                <div class="step-line" id="line2"></div>
                <div class="step-circle inactive" id="step3">3</div>
                <div class="step-line" id="line3"></div>
                <div class="step-circle inactive" id="step4">4</div>
                <div class="step-line" id="line4"></div>
                <div class="step-circle inactive" id="step5">5</div>
            </div>

            <div class="nav-buttons">
                <button class="nav-button" id="prevBtn" onclick="simulator.previousStep()" disabled>이전 단계</button>
                <button class="nav-button" id="nextBtn" onclick="simulator.nextStep()">다음 단계</button>
            </div>
        </div>

        <!-- 1단계: 사용자 설정 -->
        <div class="section active" id="section1">
            <h2>1단계: 사용자 설정</h2>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <input type="text" id="nodeName" placeholder="사용자 이름 (예: Alice)" />
                <input type="number" id="trustLevel" placeholder="신뢰도 (0-1)" step="0.1" min="0" max="1" value="0.5" />
                <button onclick="simulator.addNode()">사용자 추가</button>
            </div>
            <div id="userSetup" class="user-setup"></div>
        </div>

        <!-- 2단계: 연결 관계 설정 -->
        <div class="section" id="section2">
            <h2>2단계: 연결 관계 설정</h2>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <select id="fromNode"></select>
                <span style="font-size: 20px; align-self: center;">→</span>
                <select id="toNode"></select>
                <input type="number" id="weightInput" placeholder="연결 강도(0-1)" step="0.1" min="0" max="1" value="0.5" />
                <button onclick="simulator.addConnection()">연결 추가</button>
                <button onclick="simulator.generateRandomConnections()">랜덤 연결</button>
            </div>
            <div id="edgeList"></div>
        </div>

        <!-- 3단계: 시작 감염자 설정 -->
        <div class="section" id="section3">
            <h2>3단계: 시작 감염자 설정</h2>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <select id="startInfected"></select>
                <button onclick="simulator.addStarter()">시작 감염자 추가</button>
            </div>
            <div id="startList"></div>
        </div>

        <!-- 4단계: 차단 사용자 설정 -->
        <div class="section" id="section4">
            <h2>4단계: 차단 사용자 설정</h2>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <select id="blockNode"></select>
                <button onclick="simulator.addBlock()">사용자 차단</button>
            </div>
            <div id="blockList"></div>
        </div>

        <!-- 5단계: 시뮬레이션 실행 -->
        <div class="section" id="section5">
            <h2>5단계: 시뮬레이션 실행</h2>

            <!-- 시뮬레이션 컨트롤 -->
            <div class="simulation-controls">
                <button onclick="simulator.simulateInfection()" id="startBtn">시뮬레이션 시작</button>
                <button onclick="simulator.pauseSimulation()" id="pauseBtn" disabled>일시정지</button>
                <button onclick="simulator.resetSimulation()" id="resetBtn">초기화</button>
                <button onclick="simulator.stepByStep()" id="stepBtn">단계별 실행</button>
            </div>

            <!-- 감염 단계 네비게이션 -->
            <div id="infectionStepNavigation" style="display: none;">
                <div class="step-navigation" style="background: linear-gradient(45deg, #e74c3c, #c0392b);">
                    <div class="step-title" id="infectionStepTitle">감염 0단계: 초기 상태</div>
                    <div class="step-description" id="infectionStepDescription">시뮬레이션이 시작되었습니다</div>

                    <div class="step-indicator" id="infectionStepIndicator">
                        <!-- 동적으로 생성됨 -->
                    </div>

                    <div class="nav-buttons">
                        <button class="nav-button" id="prevInfectionBtn" onclick="simulator.previousInfectionStep()" disabled>이전 감염단계</button>
                        <button class="nav-button" id="nextInfectionBtn" onclick="simulator.nextInfectionStep()">다음 감염단계</button>
                        <button class="nav-button" id="autoPlayBtn" onclick="simulator.toggleAutoPlay()">자동 재생</button>
                    </div>
                </div>
            </div>

            <div id="stepInfo" class="step-info" style="display: none;"></div>
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill" style="width: 0%;"></div>
            </div>

            <div id="graphArea">
                <div id="network"></div>
                <div class="stats-panel">
                    <h3>📊 실시간 통계</h3>
                    <div id="statisticsPanel"></div>
                    <div id="spreadRate" class="spread-rate"></div>
                </div>
                <div class="log-panel">
                    <h3>📝 감염 로그</h3>
                    <div id="simulationLog" class="simulation-log"></div>
                </div>
            </div>
        </div>

        <div id="finalResults" style="display: none;"></div>
    </div>

    <script>
        class FakeNewsSimulator {
            constructor() {
                this.nodes = [];
                this.edges = [];
                this.graphEdges = [];
                this.nodeColors = {};
                this.blockedNodes = new Set();
                this.startNodes = new Set();
                this.trustLevels = {};
                this.infectedNodes = new Set();
                this.infectionHistory = [];
                this.currentStep = 0;
                this.simulationRunning = false;
                this.simulationPaused = false;
                this.colorPalette = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'];
                this.simulationQueue = [];
                this.infectionLog = [];
                this.statistics = {
                    totalUsers: 0,
                    infectedUsers: 0,
                    blockedUsers: 0,
                    infectionRate: 0,
                    maxSpreadUser: null,
                    maxSpreadCount: 0,
                    currentStep: 0,
                    spreadCount: {}
                };
                this.stepInfections = [];

                // 단계 네비게이션 관련
                this.currentWizardStep = 1;
                this.maxSteps = 5;

                // 감염 단계 네비게이션 관련
                this.infectionSteps = []; // 각 감염 단계의 스냅샷 저장
                this.currentInfectionStep = 0;
                this.isAutoPlaying = false;
                this.autoPlayInterval = null;

                this.initEventListeners();
                this.updateStepNavigation();
                this.drawGraph();
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // 단계 네비게이션 관련 메서드들
            nextStep() {
                if (this.validateCurrentStep()) {
                    if (this.currentWizardStep < this.maxSteps) {
                        this.currentWizardStep++;
                        this.updateStepNavigation();
                        this.showCurrentSection();
                    }
                }
            }

            previousStep() {
                if (this.currentWizardStep > 1) {
                    this.currentWizardStep--;
                    this.updateStepNavigation();
                    this.showCurrentSection();
                }
            }

            validateCurrentStep() {
                switch (this.currentWizardStep) {
                    case 1:
                        if (this.nodes.length === 0) {
                            alert("최소 1명의 사용자를 추가해주세요.");
                            return false;
                        }
                        break;
                    case 2:
                        if (this.nodes.length < 2) {
                            alert("연결을 위해 최소 2명의 사용자가 필요합니다.");
                            return false;
                        }
                        if (this.graphEdges.length === 0) {
                            alert("최소 1개의 연결을 추가해주세요.");
                            return false;
                        }
                        break;
                    case 3:
                        if (this.startNodes.size === 0) {
                            alert("최소 1명의 시작 감염자를 설정해주세요.");
                            return false;
                        }
                        break;
                    case 4:
                        // 차단 사용자는 선택사항이므로 검증하지 않음
                        break;
                    case 5:
                        // 시뮬레이션 단계는 검증하지 않음
                        break;
                }
                return true;
            }

            updateStepNavigation() {
                const stepTitles = {
                    1: { title: "1단계: 사용자 설정", desc: "네트워크에 참여할 사용자들을 추가하고 신뢰도를 설정하세요" },
                    2: { title: "2단계: 연결 관계 설정", desc: "사용자들 간의 연결과 신뢰 강도를 설정하세요" },
                    3: { title: "3단계: 시작 감염자 설정", desc: "정보 전파를 시작할 초기 감염자를 선택하세요" },
                    4: { title: "4단계: 차단 사용자 설정", desc: "정보 전파를 차단할 사용자들을 선택하세요 (선택사항)" },
                    5: { title: "5단계: 시뮬레이션 실행", desc: "설정이 완료되었습니다. 시뮬레이션을 실행해보세요!" }
                };

                document.getElementById("stepTitle").textContent = stepTitles[this.currentWizardStep].title;
                document.getElementById("stepDescription").textContent = stepTitles[this.currentWizardStep].desc;

                // 단계 표시기 업데이트
                for (let i = 1; i <= this.maxSteps; i++) {
                    const stepCircle = document.getElementById(`step${i}`);
                    const stepLine = document.getElementById(`line${i}`);

                    if (i < this.currentWizardStep) {
                        stepCircle.className = "step-circle completed";
                        if (stepLine) stepLine.className = "step-line completed";
                    } else if (i === this.currentWizardStep) {
                        stepCircle.className = "step-circle active";
                        if (stepLine) stepLine.className = "step-line";
                    } else {
                        stepCircle.className = "step-circle inactive";
                        if (stepLine) stepLine.className = "step-line";
                    }
                }

                // 네비게이션 버튼 상태 업데이트
                document.getElementById("prevBtn").disabled = this.currentWizardStep === 1;
                document.getElementById("nextBtn").disabled = this.currentWizardStep === this.maxSteps;

                if (this.currentWizardStep === this.maxSteps) {
                    document.getElementById("nextBtn").textContent = "완료";
                } else {
                    document.getElementById("nextBtn").textContent = "다음 단계";
                }
            }

            showCurrentSection() {
                // 모든 섹션 숨기기
                for (let i = 1; i <= this.maxSteps; i++) {
                    document.getElementById(`section${i}`).classList.remove('active');
                }

                // 현재 섹션 표시
                document.getElementById(`section${this.currentWizardStep}`).classList.add('active');
            }

            initEventListeners() {
                document.getElementById("nodeName").addEventListener("keydown", (e) => {
                    if (e.key === "Enter") {
                        e.preventDefault();
                        this.addNode();
                    }
                });
            }

            // 사용자 추가 기능
            addNode() {
                const nameInput = document.getElementById("nodeName");
                const trustInput = document.getElementById("trustLevel");
                const name = nameInput.value.trim();
                const trust = parseFloat(trustInput.value) || 0.5;

                if (!name) {
                    alert("사용자 이름을 입력해주세요.");
                    return;
                }

                if (this.nodes.includes(name)) {
                    alert("이미 존재하는 사용자입니다.");
                    return;
                }

                this.nodes.push(name);
                this.nodeColors[name] = this.colorPalette[this.nodes.length % this.colorPalette.length];
                this.trustLevels[name] = Math.max(0, Math.min(1, trust));
                this.statistics.spreadCount[name] = 0;

                this.updateMenus();
                this.updateUserSetup();
                this.updateStatistics();
                this.drawGraph();

                nameInput.value = "";
                trustInput.value = "0.5";
            }

            // 랜덤 사용자 생성
            generateRandomUsers() {
                const count = parseInt(prompt("생성할 사용자 수를 입력하세요 (3-10):", "5"));
                if (isNaN(count) || count < 3 || count > 10) {
                    alert("3명에서 10명 사이의 숫자를 입력해주세요.");
                    return;
                }

                // 기존 데이터 완전 초기화
                this.resetAllData();

                // 랜덤 알파벳 대문자 생성 함수
                const generateRandomName = (usedNames) => {
                    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                    let name;
                    do {
                        name = alphabet[Math.floor(Math.random() * alphabet.length)];
                    } while (usedNames.includes(name));
                    return name;
                };

                const usedNames = [];

                // 사용자 생성
                for (let i = 0; i < count; i++) {
                    const name = generateRandomName(usedNames);
                    usedNames.push(name);

                    this.nodes.push(name);
                    this.nodeColors[name] = this.colorPalette[i % this.colorPalette.length];
                    // 0.0 ~ 1.0 사이의 완전 랜덤 신뢰도 (소수점 둘째자리까지)
                    this.trustLevels[name] = Math.round(Math.random() * 100) / 100;
                    this.statistics.spreadCount[name] = 0;
                }

                // UI 업데이트
                this.updateMenus();
                this.updateUserSetup();
                this.updateStatistics();
                this.drawGraph();

                alert(`${count}명의 사용자가 생성되었습니다!\n생성된 사용자: ${this.nodes.join(', ')}`);
            }

            // 모든 데이터 초기화
            resetAllData() {
                this.nodes = [];
                this.edges = [];
                this.graphEdges = [];
                this.nodeColors = {};
                this.blockedNodes.clear();
                this.startNodes.clear();
                this.trustLevels = {};
                this.infectedNodes.clear();
                this.infectionHistory = [];
                this.infectionLog = [];
                this.simulationQueue = [];
                this.stepInfections = [];
                this.infectionSteps = [];
                this.currentInfectionStep = 0;
                this.currentStep = 0;
                this.simulationRunning = false;
                this.simulationPaused = false;
                this.statistics = {
                    totalUsers: 0,
                    infectedUsers: 0,
                    blockedUsers: 0,
                    infectionRate: 0,
                    maxSpreadUser: null,
                    maxSpreadCount: 0,
                    currentStep: 0,
                    spreadCount: {}
                };

                // UI 초기화
                document.getElementById("edgeList").innerHTML = "";
                document.getElementById("startList").innerHTML = "";
                document.getElementById("blockList").innerHTML = "";
                document.getElementById("userSetup").innerHTML = "";
                document.getElementById("simulationLog").innerHTML = "";
                document.getElementById("infectionStepNavigation").style.display = "none";
                document.getElementById("stepInfo").style.display = "none";
                document.getElementById("finalResults").style.display = "none";
            }

            // 사용자 설정 UI 업데이트
            updateUserSetup() {
                const container = document.getElementById("userSetup");
                container.innerHTML = "";

                this.nodes.forEach(name => {
                    const card = document.createElement("div");
                    card.className = `user-card ${this.blockedNodes.has(name) ? 'blocked' : ''}`;
                    card.innerHTML = `
                            <h4>${name}</h4>
                            <label>신뢰도: <span id="trust-${name}">${this.trustLevels[name].toFixed(2)}</span></label>
                            <input type="range" class="trust-slider" min="0" max="1" step="0.1"
                                   value="${this.trustLevels[name]}"
                                   onchange="simulator.updateTrust('${name}', this.value)">
                            <div style="margin-top: 10px;">
                                ${this.blockedNodes.has(name) ?
                            `<button onclick="simulator.unblockUser('${name}')" style="background: #27ae60;">차단 해제</button>` :
                            `<button onclick="simulator.blockUser('${name}')" style="background: #e74c3c;">차단</button>`
                        }
                            </div>
                        `;
                    container.appendChild(card);
                });
            }

            // 신뢰도 업데이트
            updateTrust(name, value) {
                this.trustLevels[name] = parseFloat(value);
                document.getElementById(`trust-${name}`).textContent = parseFloat(value).toFixed(2);
            }

            // 사용자 차단
            blockUser(name) {
                this.blockedNodes.add(name);
                this.startNodes.delete(name);
                this.updateMenus();
                this.updateUserSetup();
                this.updateBlockList();
                this.updateStartList();
                this.updateStatistics();
                this.drawGraph();
            }

            // 사용자 차단 해제
            unblockUser(name) {
                this.blockedNodes.delete(name);
                this.updateMenus();
                this.updateUserSetup();
                this.updateBlockList();
                this.updateStatistics();
                this.drawGraph();
            }

            // 메뉴 업데이트
            updateMenus() {
                const menus = ["fromNode", "toNode", "blockNode"];
                menus.forEach(id => {
                    const sel = document.getElementById(id);
                    sel.innerHTML = "";
                    this.nodes.forEach(n => sel.add(new Option(n, n)));
                });

                const startSel = document.getElementById("startInfected");
                startSel.innerHTML = "";
                this.nodes.forEach(n => {
                    if (!this.blockedNodes.has(n)) {
                        startSel.add(new Option(n, n));
                    }
                });
            }

            // 연결 추가
            addConnection() {
                const from = document.getElementById("fromNode").value;
                const to = document.getElementById("toNode").value;
                const weight = parseFloat(document.getElementById("weightInput").value) || 0.5;

                if (!from || !to) {
                    alert("출발 사용자와 도착 사용자를 선택해주세요.");
                    return;
                }

                if (from === to) {
                    alert("자기 자신에게는 연결할 수 없습니다.");
                    return;
                }

                const edgeKey = `${from}-${to}`;
                if (this.edges.includes(edgeKey)) {
                    alert("이미 존재하는 연결입니다.");
                    return;
                }

                this.edges.push(edgeKey);
                this.graphEdges.push({ source: from, target: to, weight: Math.max(0, Math.min(1, weight)) });

                this.createConnectionBlock(from, to, weight, "edgeList");
                this.drawGraph();
                document.getElementById("weightInput").value = "0.5";
            }

            // 랜덤 연결 생성
            generateRandomConnections() {
                if (this.nodes.length < 2) {
                    alert("최소 2명의 사용자가 필요합니다.");
                    return;
                }

                const connectionCount = Math.min(this.nodes.length * 2, this.nodes.length * (this.nodes.length - 1) / 2);
                let attempts = 0;
                const maxAttempts = connectionCount * 3;

                while (this.edges.length < connectionCount && attempts < maxAttempts) {
                    const from = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                    const to = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                    const weight = Math.random() * 0.8 + 0.2;

                    if (from !== to && !this.edges.includes(`${from}-${to}`)) {
                        this.edges.push(`${from}-${to}`);
                        this.graphEdges.push({ source: from, target: to, weight });
                        this.createConnectionBlock(from, to, weight, "edgeList");
                    }
                    attempts++;
                }
                this.drawGraph();
            }

            // 연결 블록 생성
            createConnectionBlock(from, to, weight, containerId) {
                const container = document.getElementById(containerId);
                const div = document.createElement("div");
                div.className = "connection-block";
                div.innerHTML = `
                        <span class='from-node'>${from}</span> →
                        <span class='to-node'>${to}</span>
                        <span class='green-bold'>(${weight.toFixed(2)})</span>
                    `;
                div.onclick = () => this.removeConnection(from, to, div);
                container.appendChild(div);
            }

            // 연결 제거
            removeConnection(from, to, element) {
                if (confirm(`${from} → ${to} 연결을 삭제하시겠습니까?`)) {
                    const edgeKey = `${from}-${to}`;
                    this.edges = this.edges.filter(e => e !== edgeKey);
                    this.graphEdges = this.graphEdges.filter(e => !(e.source === from && e.target === to));
                    element.remove();
                    this.drawGraph();
                }
            }

            // 시작 감염자 추가
            addStarter() {
                const selected = document.getElementById("startInfected").value;
                if (!selected) {
                    alert("시작 감염자를 선택해주세요.");
                    return;
                }

                if (this.startNodes.has(selected)) {
                    alert("이미 선택된 감염자입니다.");
                    return;
                }

                this.startNodes.add(selected);
                this.updateStartList();
                this.drawGraph();
            }

            // 다중 시작 감염자 설정
            addMultipleStarters() {
                const count = parseInt(prompt("시작 감염자 수를 입력하세요:", "2"));
                if (!count || count < 1) return;

                const availableNodes = this.nodes.filter(n => !this.blockedNodes.has(n) && !this.startNodes.has(n));
                if (availableNodes.length === 0) {
                    alert("추가할 수 있는 감염자가 없습니다.");
                    return;
                }

                const selectedCount = Math.min(count, availableNodes.length);

                for (let i = 0; i < selectedCount; i++) {
                    const randomIndex = Math.floor(Math.random() * availableNodes.length);
                    this.startNodes.add(availableNodes.splice(randomIndex, 1)[0]);
                }

                this.updateStartList();
                this.drawGraph();
            }

            // 시작 감염자 목록 업데이트
            updateStartList() {
                const container = document.getElementById("startList");
                container.innerHTML = "";

                this.startNodes.forEach(name => {
                    const div = document.createElement("div");
                    div.className = "connection-block";
                    div.innerHTML = `<span class='from-node'>${name} 시작 감염자</span>`;
                    div.onclick = () => this.removeStarter(name, div);
                    container.appendChild(div);
                });
            }

            // 시작 감염자 제거
            removeStarter(name, element) {
                this.startNodes.delete(name);
                element.remove();
                this.drawGraph();
            }

            // 차단 사용자 추가
            addBlock() {
                const selected = document.getElementById("blockNode").value;
                if (!selected) {
                    alert("차단할 사용자를 선택해주세요.");
                    return;
                }

                if (this.blockedNodes.has(selected)) {
                    alert("이미 차단된 사용자입니다.");
                    return;
                }

                this.blockUser(selected);
            }

            // 다중 차단
            addMultipleBlocks() {
                const count = parseInt(prompt("차단할 사용자 수를 입력하세요:", "2"));
                if (!count || count < 1) return;

                const availableNodes = this.nodes.filter(n => !this.blockedNodes.has(n));
                if (availableNodes.length === 0) {
                    alert("차단할 수 있는 사용자가 없습니다.");
                    return;
                }

                const selectedCount = Math.min(count, availableNodes.length);

                for (let i = 0; i < selectedCount; i++) {
                    const randomIndex = Math.floor(Math.random() * availableNodes.length);
                    this.blockUser(availableNodes.splice(randomIndex, 1)[0]);
                }
            }

            // 차단 목록 업데이트
            updateBlockList() {
                const container = document.getElementById("blockList");
                container.innerHTML = "";

                this.blockedNodes.forEach(name => {
                    const div = document.createElement("div");
                    div.className = "connection-block";
                    div.innerHTML = `<span class='from-node'>${name} 차단됨</span>`;
                    div.onclick = () => this.removeBlock(name, div);
                    container.appendChild(div);
                });
            }

            // 차단 제거
            removeBlock(name, element) {
                this.unblockUser(name);
                element.remove();
            }

            // 감염 시뮬레이션 시작
            async simulateInfection() {
                if (this.startNodes.size === 0) {
                    alert("시작 감염자를 설정해주세요.");
                    return;
                }

                if (this.graphEdges.length === 0) {
                    alert("연결 관계를 설정해주세요.");
                    return;
                }

                this.resetSimulationData();
                this.simulationRunning = true;
                this.simulationPaused = false;

                document.getElementById("startBtn").disabled = true;
                document.getElementById("pauseBtn").disabled = false;
                document.getElementById("stepInfo").style.display = "block";
                document.getElementById("finalResults").style.display = "none";
                document.getElementById("infectionStepNavigation").style.display = "block";

                // 감염 단계 기록 시작
                this.infectionSteps = [];
                this.currentInfectionStep = 0;

                // 초기 상태 기록 (0단계)
                this.infectionSteps.push({
                    step: 0,
                    infected: new Set(),
                    description: "초기 상태",
                    logs: [],
                    queueCount: 0,
                    timestamp: new Date().toLocaleTimeString()
                });

                // 초기 감염자 설정 (1단계)
                this.currentStep = 1;
                this.infectedNodes = new Set([...this.startNodes]);
                this.simulationQueue = [...this.startNodes];

                // 초기 감염자 로그
                const initialLogs = [];
                this.startNodes.forEach(name => {
                    const log = `${name} - 초기 감염자`;
                    this.logInfection(name, 1, "초기 감염자");
                    initialLogs.push(log);
                });

                // 초기 감염자들의 대기 상태 계산
                let initialQueueCount = 0;
                this.startNodes.forEach(infectedNode => {
                    const hasUninfectedConnections = this.graphEdges.some(edge =>
                        edge.source === infectedNode &&
                        !this.startNodes.has(edge.target) &&
                        !this.blockedNodes.has(edge.target)
                    );
                    if (hasUninfectedConnections) {
                        initialQueueCount++;
                    }
                });

                this.infectionSteps.push({
                    step: 1,
                    infected: new Set(this.infectedNodes),
                    description: "초기 감염자 설정",
                    logs: initialLogs,
                    queueCount: initialQueueCount,
                    timestamp: new Date().toLocaleTimeString()
                });

                // BFS 기반 전파 시뮬레이션
                let stepCount = 1;
                while (this.simulationQueue.length > 0 && this.simulationRunning) {
                    stepCount++;
                    const stepResult = await this.simulateStepWithRecord(stepCount);

                    if (stepResult.newInfections === 0) {
                        break;
                    }

                    if (!this.simulationPaused) {
                        await this.delay(1000);
                    }
                }

                // 감염 단계 네비게이션 업데이트
                this.updateInfectionStepNavigation();
                this.showInfectionStep(this.infectionSteps.length - 1);

                if (this.simulationRunning) {
                    this.completeSimulation();
                }
            }

            // 단계별 시뮬레이션 (기록 포함)
            async simulateStepWithRecord(stepNumber) {
                const currentQueue = [...this.simulationQueue];
                this.simulationQueue = [];
                let newInfections = 0;
                const stepLogs = [];

                for (const currentNode of currentQueue) {
                    const connections = this.graphEdges.filter(edge => edge.source === currentNode);

                    for (const connection of connections) {
                        const target = connection.target;

                        if (!this.infectedNodes.has(target) && !this.blockedNodes.has(target)) {
                            const probability = this.trustLevels[target] * connection.weight;
                            const random = Math.random();

                            if (random < probability) {
                                this.infectedNodes.add(target);
                                this.simulationQueue.push(target);
                                this.statistics.spreadCount[currentNode]++;

                                const logMessage = `${target} ← ${currentNode} (확률: ${(probability * 100).toFixed(1)}%)`;
                                this.logInfection(target, stepNumber, `${currentNode}로부터 감염 (확률: ${(probability * 100).toFixed(1)}%)`);
                                stepLogs.push(logMessage);
                                newInfections++;
                            }
                        }
                    }
                }

                // 이 단계의 결과 기록 (큐 카운트 포함)
                const stepDescription = newInfections > 0 ?
                    `${newInfections}명 새로 감염됨` :
                    "더 이상 감염되지 않음";

                // 다음 단계를 위한 큐 카운트 계산
                let nextQueueCount = 0;
                if (this.simulationQueue.length > 0) {
                    this.infectedNodes.forEach(infectedNode => {
                        const hasUninfectedConnections = this.graphEdges.some(edge =>
                            edge.source === infectedNode &&
                            !this.infectedNodes.has(edge.target) &&
                            !this.blockedNodes.has(edge.target)
                        );
                        if (hasUninfectedConnections) {
                            nextQueueCount++;
                        }
                    });
                }

                this.infectionSteps.push({
                    step: stepNumber,
                    infected: new Set(this.infectedNodes),
                    description: stepDescription,
                    logs: [...stepLogs],
                    queueCount: this.simulationQueue.length,
                    timestamp: new Date().toLocaleTimeString()
                });

                this.currentStep = stepNumber;
                this.updateStepInfo();
                this.updateStatistics();
                this.drawGraph();
                this.updateProgress();

                return { newInfections, stepLogs };
            }

            // 감염 단계 기록
            recordInfectionStep(stepNumber, infectedSet, description, logs) {
                // 이전 단계에서 현재 감염된 사람들 중 누가 전파 가능한지 계산
                let queueCount = 0;
                if (stepNumber > 0) {
                    infectedSet.forEach(infectedNode => {
                        const hasUninfectedConnections = this.graphEdges.some(edge =>
                            edge.source === infectedNode &&
                            !infectedSet.has(edge.target) &&
                            !this.blockedNodes.has(edge.target)
                        );
                        if (hasUninfectedConnections) {
                            queueCount++;
                        }
                    });
                }

                this.infectionSteps.push({
                    step: stepNumber,
                    infected: new Set(infectedSet),
                    description: description,
                    logs: [...logs],
                    queueCount: queueCount, // 대기 중인 전파자 수 저장
                    timestamp: new Date().toLocaleTimeString()
                });
            }

            // 감염 단계 네비게이션 업데이트
            updateInfectionStepNavigation() {
                const indicator = document.getElementById("infectionStepIndicator");
                indicator.innerHTML = "";

                this.infectionSteps.forEach((step, index) => {
                    if (index > 0) {
                        const line = document.createElement("div");
                        line.className = index <= this.currentInfectionStep ? "step-line completed" : "step-line";
                        indicator.appendChild(line);
                    }

                    const circle = document.createElement("div");
                    circle.className = index === this.currentInfectionStep ? "step-circle active" :
                        index < this.currentInfectionStep ? "step-circle completed" : "step-circle inactive";
                    circle.textContent = step.step;
                    circle.onclick = () => this.showInfectionStep(index);
                    indicator.appendChild(circle);
                });

                // 네비게이션 버튼 상태 업데이트
                document.getElementById("prevInfectionBtn").disabled = this.currentInfectionStep === 0;
                document.getElementById("nextInfectionBtn").disabled = this.currentInfectionStep === this.infectionSteps.length - 1;
            }

            // 특정 감염 단계 표시
            showInfectionStep(stepIndex) {
                if (stepIndex < 0 || stepIndex >= this.infectionSteps.length) return;

                this.currentInfectionStep = stepIndex;
                const step = this.infectionSteps[stepIndex];

                // 해당 단계의 감염 상태로 복원
                this.infectedNodes = new Set(step.infected);
                this.currentStep = step.step;

                // 해당 단계의 대기열 계산
                if (stepIndex < this.infectionSteps.length - 1) {
                    // 다음 단계에서 새로 감염될 예정인 사람들을 대기열로 설정
                    const nextStep = this.infectionSteps[stepIndex + 1];
                    const currentInfected = step.infected;
                    const nextInfected = nextStep.infected;

                    this.simulationQueue = [];
                    nextInfected.forEach(name => {
                        if (!currentInfected.has(name)) {
                            // 이 단계에서 새로 감염될 예정인 사람들을 찾아서 대기열에 추가
                            // 실제로는 누가 전파했는지 추적하기 어려우므로 간단히 처리
                        }
                    });

                    // 현재 단계에서 감염된 사람들 중 연결이 있는 사람들을 대기열로 설정
                    if (step.step > 0) {
                        step.infected.forEach(infectedNode => {
                            const hasConnections = this.graphEdges.some(edge =>
                                edge.source === infectedNode &&
                                !step.infected.has(edge.target) &&
                                !this.blockedNodes.has(edge.target)
                            );
                            if (hasConnections && stepIndex < this.infectionSteps.length - 1) {
                                if (!this.simulationQueue.includes(infectedNode)) {
                                    this.simulationQueue.push(infectedNode);
                                }
                            }
                        });
                    }
                } else {
                    // 마지막 단계인 경우 대기열 비우기
                    this.simulationQueue = [];
                }

                // UI 업데이트
                document.getElementById("infectionStepTitle").textContent = `감염 ${step.step}단계`;
                document.getElementById("infectionStepDescription").textContent = step.description;

                this.updateInfectionStepNavigation();
                this.updateStepInfo(); // 이 부분이 중요! 단계 정보 업데이트
                this.updateStatistics();
                this.drawGraph();

                // 해당 단계의 로그 표시
                this.displayStepLogs(step);
            }

            // 단계별 로그 표시
            displayStepLogs(step) {
                const logContainer = document.getElementById("simulationLog");
                logContainer.innerHTML = `
                        <div style="font-weight: bold; color: #2c3e50; margin-bottom: 10px;">
                            ${step.step}단계 감염 기록 (${step.timestamp})
                        </div>
                    `;

                if (step.logs.length === 0) {
                    const div = document.createElement("div");
                    div.className = "log-entry";
                    div.textContent = step.step === 0 ? "아직 감염자가 없습니다." : "이 단계에서는 새로운 감염이 없었습니다.";
                    logContainer.appendChild(div);
                } else {
                    step.logs.forEach(log => {
                        const div = document.createElement("div");
                        div.className = "log-entry";
                        div.textContent = log;
                        logContainer.appendChild(div);
                    });
                }
            }

            // 감염 단계 네비게이션
            previousInfectionStep() {
                if (this.currentInfectionStep > 0) {
                    this.showInfectionStep(this.currentInfectionStep - 1);
                }
            }

            nextInfectionStep() {
                if (this.currentInfectionStep < this.infectionSteps.length - 1) {
                    this.showInfectionStep(this.currentInfectionStep + 1);
                }
            }

            // 자동 재생 토글
            toggleAutoPlay() {
                this.isAutoPlaying = !this.isAutoPlaying;
                const btn = document.getElementById("autoPlayBtn");

                if (this.isAutoPlaying) {
                    btn.textContent = "자동 재생 중지";
                    this.startAutoPlay();
                } else {
                    btn.textContent = "자동 재생";
                    this.stopAutoPlay();
                }
            }

            // 자동 재생 시작
            startAutoPlay() {
                this.autoPlayInterval = setInterval(() => {
                    if (this.currentInfectionStep < this.infectionSteps.length - 1) {
                        this.nextInfectionStep();
                    } else {
                        // 마지막 단계에 도달하면 처음부터 다시
                        this.showInfectionStep(0);
                    }
                }, 2000);
            }

            // 자동 재생 중지
            stopAutoPlay() {
                if (this.autoPlayInterval) {
                    clearInterval(this.autoPlayInterval);
                    this.autoPlayInterval = null;
                }
            }

            // 한 단계 시뮬레이션
            async simulateStep() {
                const currentQueue = [...this.simulationQueue];
                this.simulationQueue = [];
                let newInfections = 0;

                for (const currentNode of currentQueue) {
                    const connections = this.graphEdges.filter(edge => edge.source === currentNode);

                    for (const connection of connections) {
                        const target = connection.target;

                        if (!this.infectedNodes.has(target) && !this.blockedNodes.has(target)) {
                            const probability = this.trustLevels[target] * connection.weight;
                            const random = Math.random();

                            if (random < probability) {
                                this.infectedNodes.add(target);
                                this.simulationQueue.push(target);
                                this.statistics.spreadCount[currentNode]++;
                                this.logInfection(target, this.currentStep, `${currentNode}로부터 감염 (확률: ${(probability * 100).toFixed(1)}%)`);
                                newInfections++;
                            }
                        }
                    }
                }

                this.currentStep++;
                this.updateStepInfo();
                this.updateStatistics();
                this.drawGraph();
                this.updateProgress();

                if (newInfections === 0) {
                    this.simulationQueue = [];
                }
            }

            // 단계별 실행
            stepByStep() {
                if (!this.simulationRunning) {
                    this.simulateInfection();
                    this.pauseSimulation();
                } else {
                    this.simulationPaused = false;
                    this.simulateStep().then(() => {
                        this.simulationPaused = true;
                        if (this.simulationQueue.length === 0) {
                            this.completeSimulation();
                        }
                    });
                }
            }

            // 시뮬레이션 일시정지/재시작
            pauseSimulation() {
                this.simulationPaused = !this.simulationPaused;
                document.getElementById("pauseBtn").textContent = this.simulationPaused ? "재시작" : "일시정지";

                if (!this.simulationPaused && this.simulationRunning) {
                    this.continueSimulation();
                }
            }

            async continueSimulation() {
                while (this.simulationQueue.length > 0 && this.simulationRunning && !this.simulationPaused) {
                    await this.simulateStep();
                    await this.delay(1000);
                }

                if (this.simulationRunning && this.simulationQueue.length === 0) {
                    this.completeSimulation();
                }
            }

            // 시뮬레이션 초기화
            resetSimulation() {
                this.simulationRunning = false;
                this.simulationPaused = false;
                this.stopAutoPlay();
                this.isAutoPlaying = false;
                this.resetSimulationData();

                document.getElementById("startBtn").disabled = false;
                document.getElementById("pauseBtn").disabled = true;
                document.getElementById("pauseBtn").textContent = "일시정지";
                document.getElementById("stepInfo").style.display = "none";
                document.getElementById("progressFill").style.width = "0%";
                document.getElementById("finalResults").style.display = "none";
                document.getElementById("infectionStepNavigation").style.display = "none";
                document.getElementById("autoPlayBtn").textContent = "자동 재생";

                this.infectionSteps = [];
                this.currentInfectionStep = 0;

                this.updateStatistics();
                this.drawGraph();
                this.updateSimulationLog();
            }

            resetSimulationData() {
                this.currentStep = 0;
                this.infectedNodes.clear();
                this.infectionHistory = [];
                this.infectionLog = [];
                this.simulationQueue = [];
                this.stepInfections = [];

                // 전파 카운트 초기화
                this.nodes.forEach(name => {
                    this.statistics.spreadCount[name] = 0;
                });
            }

            // 시뮬레이션 완료
            completeSimulation() {
                this.simulationRunning = false;
                document.getElementById("startBtn").disabled = false;
                document.getElementById("pauseBtn").disabled = true;
                document.getElementById("pauseBtn").textContent = "일시정지";

                this.calculateFinalStatistics();
                this.showFinalResults();
            }

            // 단계 정보 업데이트
            updateStepInfo() {
                const stepInfo = document.getElementById("stepInfo");

                // 감염 단계 네비게이션이 활성화된 경우, 해당 단계 정보 사용
                if (this.infectionSteps.length > 0 && this.currentInfectionStep >= 0) {
                    const currentInfectionStepData = this.infectionSteps[this.currentInfectionStep];
                    stepInfo.innerHTML = `
                            <div>현재 단계: ${currentInfectionStepData.step}</div>
                            <div>감염자 수: ${currentInfectionStepData.infected.size}/${this.nodes.length}</div>
                            <div>대기 중: ${currentInfectionStepData.queueCount || 0}명</div>
                        `;
                } else {
                    // 일반적인 경우
                    stepInfo.innerHTML = `
                            <div>현재 단계: ${this.currentStep}</div>
                            <div>감염자 수: ${this.infectedNodes.size}/${this.nodes.length}</div>
                            <div>대기 중: ${this.simulationQueue.length}명</div>
                        `;
                }
            }

            // 진행률 업데이트
            updateProgress() {
                const progress = this.nodes.length > 0 ? (this.infectedNodes.size / this.nodes.length) * 100 : 0;
                document.getElementById("progressFill").style.width = `${progress}%`;
            }

            // 감염 로그 기록
            logInfection(name, step, reason) {
                this.infectionLog.push({
                    name: name,
                    step: step,
                    reason: reason,
                    timestamp: new Date().toLocaleTimeString()
                });
                this.updateSimulationLog();
            }

            // 시뮬레이션 로그 업데이트
            updateSimulationLog() {
                const logContainer = document.getElementById("simulationLog");
                logContainer.innerHTML = "";

                this.infectionLog.forEach(entry => {
                    const div = document.createElement("div");
                    div.className = "log-entry";
                    div.innerHTML = `
                            <strong>${entry.name}</strong> - 단계 ${entry.step}<br>
                            ${entry.reason}<br>
                            <small>${entry.timestamp}</small>
                        `;
                    logContainer.appendChild(div);
                });

                logContainer.scrollTop = logContainer.scrollHeight;
            }

            // 통계 업데이트
            updateStatistics() {
                this.statistics.totalUsers = this.nodes.length;
                this.statistics.infectedUsers = this.infectedNodes.size;
                this.statistics.blockedUsers = this.blockedNodes.size;
                this.statistics.infectionRate = this.nodes.length > 0 ? this.infectedNodes.size / this.nodes.length : 0;
                this.statistics.currentStep = this.currentStep;

                this.updateStatisticsPanel();
            }

            // 통계 패널 업데이트
            updateStatisticsPanel() {
                const panel = document.getElementById("statisticsPanel");
                panel.innerHTML = `
                        <div class="stat-item">
                            <div class="stat-value">${this.statistics.totalUsers}</div>
                            <div class="stat-label">총 사용자</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${this.statistics.infectedUsers}</div>
                            <div class="stat-label">감염자</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${this.statistics.blockedUsers}</div>
                            <div class="stat-label">차단됨</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${(this.statistics.infectionRate * 100).toFixed(1)}%</div>
                            <div class="stat-label">감염률</div>
                        </div>
                    `;

                // 전파율 표시
                const spreadRate = document.getElementById("spreadRate");
                const rate = this.statistics.infectionRate;
                let className, text;

                if (rate >= 0.7) {
                    className = "spread-high";
                    text = "높은 전파율";
                } else if (rate >= 0.3) {
                    className = "spread-medium";
                    text = "중간 전파율";
                } else {
                    className = "spread-low";
                    text = "낮은 전파율";
                }

                spreadRate.className = `spread-rate ${className}`;
                spreadRate.textContent = text;
            }

            // 최종 통계 계산
            calculateFinalStatistics() {
                let maxSpread = 0;
                let maxSpreadUser = null;

                for (const [user, count] of Object.entries(this.statistics.spreadCount)) {
                    if (count > maxSpread) {
                        maxSpread = count;
                        maxSpreadUser = user;
                    }
                }

                this.statistics.maxSpreadUser = maxSpreadUser;
                this.statistics.maxSpreadCount = maxSpread;
            }

            // 최종 결과 표시
            showFinalResults() {
                const resultsContainer = document.getElementById("finalResults");
                resultsContainer.style.display = "block";

                resultsContainer.innerHTML = `
                        <div class="final-results">
                            <h3>🎯 시뮬레이션 완료!</h3>
                            <div class="stat-item">
                                <div class="stat-value">${this.statistics.totalUsers}</div>
                                <div class="stat-label">총 사용자 수</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value">${this.statistics.infectedUsers}</div>
                                <div class="stat-label">감염된 사용자</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value">${(this.statistics.infectionRate * 100).toFixed(1)}%</div>
                                <div class="stat-label">최종 감염률</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value">${this.statistics.currentStep}</div>
                                <div class="stat-label">총 단계 수</div>
                            </div>
                            ${this.statistics.maxSpreadUser ? `
                            <div class="stat-item">
                                <div class="stat-value">${this.statistics.maxSpreadUser}</div>
                                <div class="stat-label">최다 전파자</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value">${this.statistics.maxSpreadCount}</div>
                                <div class="stat-label">전파 수</div>
                            </div>
                            ` : ''}
                        </div>
                    `;
            }

            // 그래프 그리기
            drawGraph() {
                const container = document.getElementById("network");
                container.innerHTML = "";

                if (this.nodes.length === 0) {
                    container.innerHTML = "<p style='text-align: center; color: #666; margin-top: 150px;'>사용자를 추가해주세요</p>";
                    return;
                }

                const width = 500, height = 500;
                const svg = d3.select("#network")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .style("background", "radial-gradient(circle, #f8f9fa 0%, #e9ecef 100%)")
                    .style("border-radius", "15px");

                // 노드 위치 계산 (원형 배치)
                const radius = Math.min(width, height) * 0.35;
                const angleStep = (2 * Math.PI) / this.nodes.length;
                const nodePositions = {};

                this.nodes.forEach((node, i) => {
                    nodePositions[node] = {
                        x: width / 2 + radius * Math.cos(i * angleStep - Math.PI / 2),
                        y: height / 2 + radius * Math.sin(i * angleStep - Math.PI / 2)
                    };
                });

                // 간선 그리기
                svg.selectAll("line")
                    .data(this.graphEdges)
                    .enter().append("line")
                    .attr("x1", d => nodePositions[d.source].x)
                    .attr("y1", d => nodePositions[d.source].y)
                    .attr("x2", d => nodePositions[d.target].x)
                    .attr("y2", d => nodePositions[d.target].y)
                    .attr("stroke", "#bdc3c7")
                    .attr("stroke-width", d => Math.max(1, d.weight * 4))
                    .attr("opacity", 0.6);

                // 간선 가중치 표시
                svg.selectAll(".edge-weight")
                    .data(this.graphEdges)
                    .enter().append("text")
                    .attr("class", "edge-weight")
                    .attr("x", d => (nodePositions[d.source].x + nodePositions[d.target].x) / 2)
                    .attr("y", d => (nodePositions[d.source].y + nodePositions[d.target].y) / 2)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "10px")
                    .attr("fill", "#666")
                    .attr("background", "white")
                    .text(d => d.weight.toFixed(1));

                // 노드 외곽 원 (상태 표시용)
                svg.selectAll(".node-border")
                    .data(this.nodes)
                    .enter().append("circle")
                    .attr("class", "node-border")
                    .attr("cx", d => nodePositions[d].x)
                    .attr("cy", d => nodePositions[d].y)
                    .attr("r", 32)
                    .attr("fill", "none")
                    .attr("stroke", d => {
                        if (this.blockedNodes.has(d)) return "#9c27b0";
                        if (this.infectedNodes.has(d)) return "#e74c3c";
                        if (this.startNodes.has(d) && !this.infectedNodes.has(d)) return "#f39c12";
                        return "transparent";
                    })
                    .attr("stroke-width", 4)
                    .attr("opacity", 0.8);

                // 노드 메인 원
                svg.selectAll(".node-main")
                    .data(this.nodes)
                    .enter().append("circle")
                    .attr("class", "node-main")
                    .attr("cx", d => nodePositions[d].x)
                    .attr("cy", d => nodePositions[d].y)
                    .attr("r", 28)
                    .attr("fill", d => {
                        if (this.blockedNodes.has(d)) return "#e8eaf6"; // 차단됨 - 연보라
                        if (this.infectedNodes.has(d)) return "#ffcdd2"; // 감염됨 - 연빨강
                        if (this.startNodes.has(d)) return "#fff3e0"; // 시작 감염자 - 연주황
                        return "#e8f5e8"; // 정상 - 연초록
                    })
                    .attr("stroke", d => {
                        if (this.blockedNodes.has(d)) return "#9c27b0";
                        if (this.infectedNodes.has(d)) return "#e74c3c";
                        if (this.startNodes.has(d)) return "#f39c12";
                        return "#4caf50";
                    })
                    .attr("stroke-width", 2)
                    .style("filter", "drop-shadow(2px 2px 4px rgba(0,0,0,0.2))");

                // 노드 상태 아이콘
                svg.selectAll(".node-icon")
                    .data(this.nodes)
                    .enter().append("text")
                    .attr("class", "node-icon")
                    .attr("x", d => nodePositions[d].x + 15)
                    .attr("y", d => nodePositions[d].y - 15)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "16px")
                    .text(d => {
                        if (this.blockedNodes.has(d)) return "🛡️";
                        if (this.infectedNodes.has(d)) return "🦠";
                        if (this.startNodes.has(d)) return "🎯";
                        return "";
                    });

                // 노드 텍스트 (사용자 이름)
                svg.selectAll(".node-text")
                    .data(this.nodes)
                    .enter().append("text")
                    .attr("class", "node-text")
                    .attr("x", d => nodePositions[d].x)
                    .attr("y", d => nodePositions[d].y + 5)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("font-weight", "bold")
                    .attr("fill", "#2c3e50")
                    .text(d => d);

                // 신뢰도 표시 (노드 아래)
                svg.selectAll(".trust-text")
                    .data(this.nodes)
                    .enter().append("text")
                    .attr("class", "trust-text")
                    .attr("x", d => nodePositions[d].x)
                    .attr("y", d => nodePositions[d].y + 45)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "10px")
                    .attr("fill", "#7f8c8d")
                    .text(d => `신뢰도: ${this.trustLevels[d]?.toFixed(1) || '0.5'}`);

                // 범례 추가
                this.drawLegend(svg, width, height);
            }

            // 범례 그리기
            drawLegend(svg, width, height) {
                const legend = svg.append("g")
                    .attr("class", "legend")
                    .attr("transform", `translate(10, 10)`);

                const legendData = [
                    { color: "#e8f5e8", border: "#4caf50", icon: "", text: "정상" },
                    { color: "#fff3e0", border: "#f39c12", icon: "🎯", text: "시작 감염자" },
                    { color: "#ffcdd2", border: "#e74c3c", icon: "🦠", text: "감염됨" },
                    { color: "#e8eaf6", border: "#9c27b0", icon: "🛡️", text: "차단됨" }
                ];

                legendData.forEach((item, i) => {
                    const legendItem = legend.append("g")
                        .attr("transform", `translate(0, ${i * 25})`);

                    legendItem.append("circle")
                        .attr("cx", 10)
                        .attr("cy", 0)
                        .attr("r", 8)
                        .attr("fill", item.color)
                        .attr("stroke", item.border)
                        .attr("stroke-width", 2);

                    if (item.icon) {
                        legendItem.append("text")
                            .attr("x", 10)
                            .attr("y", 3)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "10px")
                            .text(item.icon);
                    }

                    legendItem.append("text")
                        .attr("x", 25)
                        .attr("y", 4)
                        .attr("font-size", "12px")
                        .attr("fill", "#2c3e50")
                        .text(item.text);
                });
            }
        }

        // 전역 인스턴스 생성
        const simulator = new FakeNewsSimulator();
    </script>
